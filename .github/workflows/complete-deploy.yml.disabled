# Complete DaySave Deployment with Persistent Storage
# Full deployment workflow with persistent data and comprehensive backup strategy
name: Complete DaySave Deploy

on:
  push:
    branches: [ develop ]
  workflow_dispatch:

env:
  PROJECT_ID: ${{ vars.GCP_PROJECT_ID || 'daysave' }}
  GCP_ZONE: ${{ vars.GCP_ZONE || 'asia-southeast1-a' }}
  VM_NAME: daysave-staging
  DOMAIN_NAME: ${{ vars.DOMAIN_NAME || 'daysave.app' }}
  
jobs:
  complete-deploy:
    name: Complete Deployment
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GOOGLE_APPLICATION_CREDENTIALS }}
        
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      
    - name: Create or verify VM with persistent storage
      run: |
        echo "🚀 Ensuring VM exists with persistent storage..."
        
        # Create persistent disk for application data if it doesn't exist
        if ! gcloud compute disks describe ${{ env.VM_NAME }}-data --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} &>/dev/null; then
          echo "💾 Creating persistent disk for application data..."
          gcloud compute disks create ${{ env.VM_NAME }}-data \
            --project=${{ env.PROJECT_ID }} \
            --zone=${{ env.GCP_ZONE }} \
            --size=100GB \
            --type=pd-standard \
            --description="Persistent storage for DaySave application data, Docker volumes, SSL certificates, and backups"
        else
          echo "✅ Persistent disk already exists"
        fi
        
        if gcloud compute instances describe ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} &>/dev/null; then
          echo "✅ VM already exists"
          VM_IP=$(gcloud compute instances describe ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          echo "🌐 VM IP: $VM_IP"
        else
          echo "📦 Creating new VM with persistent boot disk..."
          gcloud compute instances create ${{ env.VM_NAME }} \
            --project=${{ env.PROJECT_ID }} \
            --zone=${{ env.GCP_ZONE }} \
            --machine-type=e2-medium \
            --image-family=ubuntu-2204-lts \
            --image-project=ubuntu-os-cloud \
            --service-account=daysave-production@${{ env.PROJECT_ID }}.iam.gserviceaccount.com \
            --scopes=cloud-platform \
            --tags=http-server,https-server \
            --boot-disk-size=50GB \
            --boot-disk-type=pd-standard \
            --create-disk=auto-delete=no,boot=yes,device-name=${{ env.VM_NAME }},mode=rw \
            --labels=environment=staging,app=daysave
            
          echo "⏳ Waiting for VM to initialize..."
          sleep 60
          
          VM_IP=$(gcloud compute instances describe ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          echo "🌐 New VM IP: $VM_IP"
        fi
        
        # Attach persistent disk to VM if not already attached
        if ! gcloud compute instances describe ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --format="value(disks[].source)" | grep -q "${{ env.VM_NAME }}-data"; then
          echo "🔗 Attaching persistent disk to VM..."
          gcloud compute instances attach-disk ${{ env.VM_NAME }} \
            --project=${{ env.PROJECT_ID }} \
            --zone=${{ env.GCP_ZONE }} \
            --disk=${{ env.VM_NAME }}-data \
            --device-name=app-data
        else
          echo "✅ Persistent disk already attached"
        fi
        
    - name: Install Docker and dependencies
      run: |
        echo "🐳 Installing Docker and dependencies..."
        gcloud compute ssh ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --command="
          # Update system
          sudo apt-get update
          
          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            echo '📦 Installing Docker...'
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker \$USER
            sudo systemctl enable docker
            sudo systemctl start docker
          else
            echo '✅ Docker already installed'
          fi
          
          # Install Docker Compose if not present
          if ! command -v docker-compose &> /dev/null; then
            echo '📦 Installing Docker Compose...'
            sudo curl -L \"https://github.com/docker/compose/releases/download/v2.21.0/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          else
            echo '✅ Docker Compose already installed'
          fi
          
          # Install additional tools
          sudo apt-get install -y git curl wget unzip
          
          echo '✅ Dependencies installed successfully'
        "
        
    - name: Setup persistent storage
      run: |
        echo "💾 Setting up persistent storage structure..."
        gcloud compute ssh ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --command="
          # Setup persistent disk mount and directory structure
          if ! mount | grep -q '/mnt/app-data'; then
            echo '💾 Setting up persistent disk...'
            
            # Format disk if not already formatted
            if ! sudo blkid /dev/sdb; then
              sudo mkfs.ext4 -F /dev/sdb
            fi
            
            # Create mount point and mount
            sudo mkdir -p /mnt/app-data
            sudo mount /dev/sdb /mnt/app-data
            
            # Add to fstab for automatic mounting
            if ! grep -q '/dev/sdb' /etc/fstab; then
              echo '/dev/sdb /mnt/app-data ext4 defaults 0 2' | sudo tee -a /etc/fstab
            fi
            
            # Create directory structure
            sudo mkdir -p /mnt/app-data/{docker-volumes,ssl-certs,backups,uploads,multimedia-temp}
            sudo chown -R \$(whoami):\$(whoami) /mnt/app-data
          else
            echo '✅ Persistent disk already mounted'
          fi
          
          # Create symlinks for Docker volumes to use persistent storage
          sudo mkdir -p /var/lib/docker/volumes
          for vol in mysql_data app_uploads app_logs app_backup redis_data nginx_ssl nginx_conf; do
            if [ ! -L /var/lib/docker/volumes/\${vol} ]; then
              # Stop any containers using the volume
              docker-compose -f ~/daysave_v1.4.1/docker-compose.production.yml down 2>/dev/null || true
              
              # Remove existing volume directory if it exists
              sudo rm -rf /var/lib/docker/volumes/\${vol}
              
              # Create persistent storage directory
              sudo mkdir -p /mnt/app-data/docker-volumes/\${vol}
              sudo chown -R \$(whoami):\$(whoami) /mnt/app-data/docker-volumes/\${vol}
              
              # Create symlink
              sudo ln -sf /mnt/app-data/docker-volumes/\${vol} /var/lib/docker/volumes/\${vol}
              
              echo \"✅ Volume \${vol} linked to persistent storage\"
            fi
          done
          
          # Setup SSL certificate persistence
          sudo mkdir -p /mnt/app-data/ssl-certs/letsencrypt
          sudo chown -R \$(whoami):\$(whoami) /mnt/app-data/ssl-certs
          
          # Move existing certificates if they exist
          if [ -d /etc/letsencrypt ] && [ ! -L /etc/letsencrypt ]; then
            echo '🔒 Moving existing SSL certificates to persistent storage...'
            sudo cp -r /etc/letsencrypt/* /mnt/app-data/ssl-certs/letsencrypt/ 2>/dev/null || true
            sudo rm -rf /etc/letsencrypt
          fi
          
          # Create symlink for SSL certificates
          if [ ! -L /etc/letsencrypt ]; then
            sudo ln -sf /mnt/app-data/ssl-certs/letsencrypt /etc/letsencrypt
            echo '✅ SSL certificates linked to persistent storage'
          fi
          
          # Create backup directory structure
          mkdir -p /mnt/app-data/backups/{automated,manual,pre-deploy}
          
          echo '✅ Persistent storage setup completed'
        "
        
    - name: Deploy application code
      run: |
        echo "📥 Deploying application code..."
        gcloud compute ssh ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --command="
          # Clone or update repository
          if [ ! -d \"daysave_v1.4.1\" ]; then
            echo '📥 Cloning repository...'
            git clone https://github.com/${{ github.repository }}.git daysave_v1.4.1
          else
            echo '🔄 Updating repository...'
            cd daysave_v1.4.1
            git fetch origin
            cd ..
          fi
          
          cd daysave_v1.4.1
          git checkout ${{ github.sha }}
          
          echo '✅ Code deployed successfully'
        "
        
    - name: Configure environment variables
      run: |
        echo "⚙️ Configuring environment variables..."
        gcloud compute ssh ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --command="
          cd daysave_v1.4.1
          
          # Create production environment file with actual secrets
          cat > .env.production << 'EOF'
        # ===== APPLICATION CONFIGURATION =====
        NODE_ENV=production
        APP_PORT=3000
        SESSION_SECRET=${{ secrets.SESSION_SECRET }}
        
        # ===== DATABASE CONFIGURATION =====
        DB_HOST=db
        DB_PORT=3306
        DB_USER=daysave
        DB_USER_PASSWORD=${{ secrets.DB_USER_PASSWORD }}
        DB_NAME=daysave_v141
        DB_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}
        
        # ===== REDIS CONFIGURATION =====
        REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
        
        # ===== GOOGLE CLOUD CONFIGURATION =====
        GOOGLE_CLOUD_PROJECT_ID=${{ env.PROJECT_ID }}
        GOOGLE_CLOUD_STORAGE_BUCKET=${{ secrets.GOOGLE_CLOUD_STORAGE_BUCKET }}
        GOOGLE_CLOUD_SPEECH_LANGUAGE=en-US
        GOOGLE_CLOUD_VISION_LANGUAGE=en
        
        # ===== OPENAI CONFIGURATION =====
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        
        # ===== OAUTH CONFIGURATION =====
        GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
        GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
        MICROSOFT_CLIENT_ID=${{ secrets.MICROSOFT_CLIENT_ID }}
        MICROSOFT_CLIENT_SECRET=${{ secrets.MICROSOFT_CLIENT_SECRET }}
        
        # ===== EMAIL CONFIGURATION =====
        GMAIL_USER=${{ secrets.GMAIL_USER }}
        GMAIL_PASS=${{ secrets.GMAIL_PASS }}
        GMAIL_FROM=${{ secrets.GMAIL_FROM }}
        
        # ===== SECURITY CONFIGURATION =====
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
        
        # ===== DOMAIN CONFIGURATION =====
        BASE_URL=https://daysave.app
        ALLOWED_ORIGINS=https://daysave.app,https://www.daysave.app
        WEBAUTHN_RP_ID=daysave.app
        WEBAUTHN_RP_NAME=DaySave
        WEBAUTHN_ORIGIN=https://daysave.app
        
        # ===== FILE UPLOAD CONFIGURATION =====
        MAX_FILE_SIZE=52428800
        ALLOWED_FILE_TYPES=image/jpeg,image/png,image/gif,application/pdf,text/plain,video/mp4,audio/mpeg,audio/wav
        
        # ===== GOOGLE MAPS CONFIGURATION =====
        GOOGLE_MAPS_API_KEY=${{ secrets.GOOGLE_MAPS_API_KEY }}
        
        # ===== LOGGING CONFIGURATION =====
        LOG_LEVEL=warn
        LOG_FILE_PATH=/usr/src/app/logs/app.log
        ENABLE_SQL_LOGGING=false
        ENABLE_MULTIMEDIA_CONSOLE_LOGGING=false
        ENABLE_STARTUP_VALIDATION_LOGGING=false
        ENABLE_PERFORMANCE_CONSOLE_LOGGING=false
        ENABLE_PROCESSOR_STEP_LOGGING=false
        ENABLE_AUTH_EVENT_LOGGING=false
        ENABLE_STATUS_POLLING_LOGGING=false
        ENABLE_ANALYSIS_REQUEST_LOGGING=false
        ENABLE_PERFORMANCE_ALERT_LOGGING=false
        
        # ===== MULTIMEDIA ANALYSIS CONFIGURATION =====
        ANALYZER_PORT=3001
        MULTIMEDIA_TEMP_DIR=/usr/src/app/multimedia-temp
        THUMBNAIL_COUNT=5
        SPEAKER_CONFIDENCE_THRESHOLD=0.7
        
        # ===== SECURITY CONFIGURATION =====
        BCRYPT_ROUNDS=12
        EOF
          
          echo '✅ Environment configured successfully'
        "
        
    - name: Setup SSL certificates with persistence
      run: |
        echo "🔒 Setting up SSL certificates with persistent storage..."
        gcloud compute ssh ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --command="
          cd daysave_v1.4.1
          
          # Create SSL directory in project (for nginx config)
          mkdir -p nginx/ssl
          
          # Check if certificates already exist in persistent storage
          if [ ! -f /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/fullchain.pem ]; then
            echo '🔒 Generating self-signed certificates for staging...'
            
            # Create certificate directory structure
            sudo mkdir -p /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}
            sudo mkdir -p /mnt/app-data/ssl-certs/letsencrypt/archive/${{ env.DOMAIN_NAME }}
            
            # Generate self-signed certificates in persistent storage
            sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
              -keyout /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/privkey.pem \
              -out /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/fullchain.pem \
              -subj '/C=US/ST=State/L=City/O=DaySave/CN=${{ env.DOMAIN_NAME }}'
            
            # Create archive copies (Let's Encrypt structure)
            sudo cp /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/privkey.pem \
                   /mnt/app-data/ssl-certs/letsencrypt/archive/${{ env.DOMAIN_NAME }}/privkey1.pem
            sudo cp /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/fullchain.pem \
                   /mnt/app-data/ssl-certs/letsencrypt/archive/${{ env.DOMAIN_NAME }}/fullchain1.pem
            
            # Set proper permissions
            sudo chmod 644 /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/fullchain.pem
            sudo chmod 600 /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/privkey.pem
            sudo chown -R \$(whoami):\$(whoami) /mnt/app-data/ssl-certs
            
            echo '✅ Self-signed SSL certificates created in persistent storage'
          else
            echo '✅ SSL certificates already exist in persistent storage'
          fi
          
          # Create symlinks in nginx/ssl directory for docker-compose
          ln -sf /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/fullchain.pem nginx/ssl/fullchain.pem
          ln -sf /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/privkey.pem nginx/ssl/privkey.pem
        "
        
    - name: Deploy with persistent blue-green strategy
      run: |
        echo "🚀 Starting persistent blue-green deployment..."
        gcloud compute ssh ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --command="
          cd daysave_v1.4.1
          
          # Ensure persistent disk is mounted
          if ! mount | grep -q '/mnt/app-data'; then
            echo '💾 Mounting persistent disk...'
            sudo mount /dev/sdb /mnt/app-data
          fi
          
          # Create comprehensive backup before deployment
          echo '📦 Creating pre-deployment backup...'
          BACKUP_TIMESTAMP=\$(date +%Y%m%d-%H%M%S)
          BACKUP_DIR=\"/mnt/app-data/backups/pre-deploy-\$BACKUP_TIMESTAMP\"
          mkdir -p \$BACKUP_DIR
          
          # Database backup (if running)
          if docker-compose -f docker-compose.production.yml ps db | grep -q Up; then
            echo '🗄️ Backing up database...'
            docker-compose -f docker-compose.production.yml exec -T db mysqldump -u root -p\$DB_ROOT_PASSWORD --single-transaction --routines --triggers --all-databases > \$BACKUP_DIR/database.sql 2>/dev/null || echo 'Database backup skipped (not running)'
          fi
          
          # Docker volumes backup
          if [ -d /mnt/app-data/docker-volumes ]; then
            echo '📁 Backing up Docker volumes...'
            sudo tar -czf \$BACKUP_DIR/docker-volumes.tar.gz -C /mnt/app-data/docker-volumes . 2>/dev/null || echo 'Volume backup skipped'
          fi
          
          # Application uploads backup
          if [ -d uploads ]; then
            echo '📤 Backing up application uploads...'
            tar -czf \$BACKUP_DIR/uploads.tar.gz uploads/ 2>/dev/null || echo 'Uploads backup skipped'
          fi
          
          # Pull latest images
          docker-compose -f docker-compose.production.yml pull
          
          # Blue-green deployment with persistent storage
          echo '🔄 Starting blue-green deployment...'
          
          # Check if any containers are running
          if docker-compose -f docker-compose.production.yml ps | grep -q Up; then
            echo '🔄 Performing blue-green deployment...'
            
            # Start new containers alongside old ones (scale up)
            docker-compose -f docker-compose.production.yml up -d --no-deps --scale app=2 app
            
            # Wait for new container to be healthy
            sleep 45
            
            # Check health of new container
            NEW_CONTAINER=\$(docker-compose -f docker-compose.production.yml ps -q app | tail -n 1)
            if docker exec \$NEW_CONTAINER curl -f http://localhost:3000/health 2>/dev/null; then
              echo '✅ New container is healthy, switching traffic...'
              
              # Scale down to single container (removes old one)
              docker-compose -f docker-compose.production.yml up -d --scale app=1 app
              
              # Run database migrations if needed
              docker-compose -f docker-compose.production.yml exec -T app npm run migrate 2>/dev/null || echo 'Migration skipped'
              
              echo '✅ Blue-green deployment completed successfully!'
            else
              echo '❌ New container failed health check, rolling back...'
              docker-compose -f docker-compose.production.yml up -d --scale app=1 app
              
              # Log rollback event
              echo \"Deployment rollback at \$(date): Health check failed for new container\" >> /mnt/app-data/backups/rollback.log
            fi
          else
            echo '🚀 Starting fresh deployment...'
            docker-compose -f docker-compose.production.yml up -d
          fi
          
          # Clean up old images but keep recent ones
          docker image prune -f --filter 'until=24h' 2>/dev/null || true
          
          # Clean up old backups (keep last 7 days locally)
          find /mnt/app-data/backups -type d -name 'pre-deploy-*' -mtime +7 -exec rm -rf {} + 2>/dev/null || true
          
          echo '⏳ Waiting for services to stabilize...'
          sleep 30
          
          echo '✅ Persistent deployment completed'
        "
        
    - name: Verify persistent deployment
      run: |
        echo "🔍 Verifying persistent deployment..."
        
        VM_IP=$(gcloud compute instances describe ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
        
        gcloud compute ssh ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }} --command="
          cd daysave_v1.4.1
          
          echo '=== Persistent Storage Status ==='
          df -h /mnt/app-data
          echo ''
          
          echo '=== Docker Volume Links ==='
          ls -la /var/lib/docker/volumes/ | grep '^l'
          echo ''
          
          echo '=== Container Status ==='
          docker ps
          echo ''
          
          echo '=== Application Health Check ==='
          if curl -f http://localhost:80/health 2>/dev/null; then
            echo '✅ Health check passed'
          else
            echo '❌ Health check failed'
          fi
          echo ''
          
          echo '=== SSL Certificate Status ==='
          if [ -L /etc/letsencrypt ]; then
            echo '✅ SSL certificates linked to persistent storage'
            ls -la /mnt/app-data/ssl-certs/letsencrypt/live/${{ env.DOMAIN_NAME }}/ 2>/dev/null || echo 'No certificates found'
          else
            echo '❌ SSL certificates not properly linked'
          fi
          echo ''
          
          echo '=== Backup Status ==='
          echo \"Recent backups:\"
          ls -la /mnt/app-data/backups/pre-deploy-* 2>/dev/null | tail -3 || echo 'No backups found'
          echo ''
          
          echo '=== Application Logs (last 10 lines) ==='
          docker-compose -f docker-compose.production.yml logs --tail=10 app 2>/dev/null || echo 'No application logs available'
        "
        
        echo "🎉 Persistent deployment completed successfully!"
        echo ""
        echo "📊 Deployment Summary:"
        echo "🌐 Application URL: http://$VM_IP"
        echo "🔒 HTTPS URL: https://$VM_IP (self-signed certificate)"
        echo "💾 Persistent Storage: 100GB disk mounted at /mnt/app-data"
        echo "🔄 Deployment Strategy: Blue-green with persistent data"
        echo "📦 Backup Strategy: Pre-deployment backups with 7-day retention"
        echo "🔗 SSL Certificates: Persistent across deployments"
        echo ""
        echo "🛠️ Management Commands:"
        echo "📋 SSH Access: gcloud compute ssh ${{ env.VM_NAME }} --zone=${{ env.GCP_ZONE }} --project=${{ env.PROJECT_ID }}"
        echo "💾 Check Storage: df -h /mnt/app-data"
        echo "📦 List Backups: ls -la /mnt/app-data/backups/"
        echo "🔍 View Logs: docker-compose -f docker-compose.production.yml logs -f app"
